<% include Rails.application.routes.url_helpers %>
<% include Rails.application.helpers %>

import React, { 
  Component
} from 'react';

import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';

import Pyr from '../pyr/pyr';
const Grid = Pyr.Grid;

import Page from './page';
import Sheet from './sheet';

const MESSAGES_URL = "/messages";

const icons = ["emilia", "snow", "sophie", "thetick"];

function getIcon(uid) {
  let pos = uid % icons.length;
  return "/assets/images/thrones/" + icons[pos] + ".jpeg";
}

class ThreadItem extends Component {
  static contextTypes = {
    user: PropTypes.object
  }

  renderIcon(message) {
    let icon = getIcon(message.from_user.id);

    return (
      <div className="flex-column icon justify-content-center align-self-center">
        <div><img src={icon}/></div>
        <div className="align-self-center">{message.from_user.first_name}</div>
      </div>
    );
  }

  render() {
    let message = this.props.message;
    let job = this.props.job;

    let mine = (message.from_user.id == this.context.user.id);
    let ownerClass = (mine ? "mine" : "yours");

    let id = "thread-item-" + message.id;
    let allClass = "thread-item " + ownerClass;

    let leftIcon = mine ? this.renderIcon(message) : null;
    let rightIcon = mine ? null : this.renderIcon(message);

    let justify = "flx-row flx-1";
    if (!mine) {
      justify = justify + " justify-content-end";
    }

    return (
      <div className={allClass} id={id}>
        <div className={justify + " created-at"}>
          {Pyr.Util.friendlyDate(message.created_at)}
        </div>
        <div className={justify}>
          { leftIcon }
          <div className="flx-col justify-content-center">
            <div className={" content flx-0"}>{message.body}</div>
          </div>
          { rightIcon }
        </div>
      </div>
    );
  }
}

class MessageItem extends Component {
  static contextTypes = {
    user: PropTypes.object
  }

  render() {
    let message = this.props.message;
    //console.log(JSON.stringify(message));

    let job = this.props.job;
    let icon = message.candidate ? message.candidate.first_name : "Q&A";

    let mine = (message.from_user.id == this.context.user.id);
    let ownerClass = (mine ? "mine" : "yours");

    let id = "message-" + message.id;

    let allClass = "message-item " + ownerClass;

    return (
      <div className={allClass} id={id}>
        <Grid.Column>
          <Grid.Row> 
            <Grid.Column className="col-1">
              {icon}
            </Grid.Column>
            <Grid.Column className="col-9">
              {job.title}
            </Grid.Column>
            <Grid.Column className="col-2">
              {Pyr.Util.friendlyDate(message.created_at)}
            </Grid.Column>
          </Grid.Row>
          <Grid.Row> 
            <Grid.Column className="col-1">
              Icon/Avatar
            </Grid.Column>
            <Grid.Column className="col-11">
              {message.title}
            </Grid.Column>
          </Grid.Row>
          <Grid.Row> 
            <Grid.ColumnFull>
              {message.body}
            </Grid.ColumnFull>
          </Grid.Row>
        </Grid.Column>
      </div>
    );
  }
}

class IndexSheet extends Sheet.Index {
  key(a) {
    return MessagesPage.key(a)
  }

  renderHeader() {
    return (
      <div>
        <h2 className="red">This is my header</h2>
      </div>
    );
  }

  renderItem(message, isSelected) {
    if (!message.thread) {
      return null;
    }

    return ( <MessageItem message={message} job={this.props.jobMap[message.job_id]} isSelected={isSelected}/> );
  }

  componentDidMount() {
    if (!this.props.items) {
      this.props.getItems(this.onLoading);
    }
  }

}

const ShowHeader = (props) => (
      <div className="message-header">
          <div className="align-self-left back"><a href="#" onClick={props.onBack}>Back</a></div>
          <div className="align-self-center title">{props.title}</div>
      </div>
);

class ShowFooter extends Component {
  render() {
    return (
      <div className="message-footer z-depth-1">
        <Pyr.Form.Form
          controller="message"
          url={MESSAGES_URL + "/" + this.props.message.id}
          id={"thread-form" + "-" + this.props.message.id}
          onSuccess={this.props.onSuccess}
          ref={(node) => this.form = node}
          reset
        >
          <div className="flx-row">
            <Pyr.Form.Group name="body" className="flx-1">
              <Pyr.Form.TextField placeholder="Reply..."/>
            </Pyr.Form.Group> 
            <Pyr.Form.SubmitButton target={this}>Reply</Pyr.Form.SubmitButton>
          </div>
        </Pyr.Form.Form>
      </div>
    );
  }
}

class ShowSheet extends Sheet.Show {
  getInitState(props) {
    return Object.assign(super.getInitState(props), { thread: null });
  }

  constructor(props) {
    super(props);

    this.onMessageDetails = this.messageDetails.bind(this);
    this.onBack = this.back.bind(this);
    this.onSuccess = this.success.bind(this);
  }

  back(e) {
    if (e) {
      e.preventDefault();
    }

    this.props.onUnaction();
  }

  success(data, textStatus, jqXHR) {
    let thread = this.state.thread || [];
    thread = thread.concat(data.message);

    this.setState({
      thread
    });
  }

  render() {
    if (this.state.isLoading) {
      return (<div className="loading" />);
    }

    let title = this.props.selected.job.title; // FIXME

    return (
      <div className="sheet flx-col-stretch flx-1">
        <div id="message-show" className="flx-1 flx-col scroll">
          <ShowHeader 
            onBack={this.onBack}
            title={title}
          />
          {this.renderInner()}
        </div>
        <ShowFooter 
          message={this.props.selected}
          onSuccess={this.onSuccess}
        />
      </div>
    );

  }


  key(a) {
    return MessagesPage.key(a)
  }

  messageDetails(message, thread) {
    //alert(JSON.stringify(thread));
    // FIXME ignore message, we already have it in props.selected - FOR NOW ;)
    this.setState({
      thread
    });
  }

  getMessage(mid) {
    let url =  MESSAGES_URL + "/" + mid;
    //alert(url);
    Pyr.getJSON({
      url: url,
      context: this,
      loading: this.onLoading
    }).done(function(data, textStatus, jaXHR) {
     this.onMessageDetails(data.message, data.thread);
   
    }).fail(function(jaXHR, textStatus, errorThrown) {
      Pyr.ajaxError(jaXHR, textStatus, errorThrown);
    });
  }

  componentDidMount() {
    if (this.props.selected) {
      this.getMessage(this.props.selected.id);
    }
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.props.selected && (this.props.selected.id != prevProps.selected.id)) {
      this.getMessage(this.props.selected.id);
    }
    let oldLength = prevState.thread ? prevState.thread.length : 0;
    let newLength = this.state.thread ? this.state.thread.length : 0;
    console.log(oldLength + " => " + newLength);
    if (oldLength != newLength) {
      if (oldLength != 0) {
        $("#message-show").stop().animate({
          scrollTop: $("#message-show")[0].scrollHeight
        }, 800);
      } else {
          $("#message-show").stop().scrollTop($("#message-show")[0].scrollHeight);
      }
  
    }
  }


  renderItem(message, isSelected) {
    if (!this.state.thread || this.state.thread.length <= 1) {
      return ( <MessageItem message={message} job={this.props.jobMap[message.job_id]} isSelected={isSelected}/> );
    }

    let thid = "thread-" + this.props.selected.root_message_id;

    return (
      <div id={thid} className="message-thread flx-1">
        { this.state.thread.map((msg, pos) => {
            //console.log(msg.job_id + " => " + JSON.stringify(this.props.jobMap[message.job_id]));
            return ( <ThreadItem message={msg} threaded job={this.props.jobMap[message.job_id]} isSelected={msg.id == this.props.selected.id} key={thid+"-"+msg.id}/> );
          })
        }
      </div>
    );
  }
}

class MessagesPage extends Page {
  getInitState(props) {
    return Object.assign(super.getInitState(props), { 
      fullDetail: true,
    });
  }

  constructor(props) {
    super(props);

    let jobs = this.props.jobs || [];
    this.jobMap = jobs.reduce((m, o) => {m[o.id] = o; return m;}, {});

  }

  key(a) {
    return "message" + "-" + a.id;
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.props.jobs != prevProps.jobs) {
      let jobs = this.props.jobs || [];
      this.jobMap = jobs.reduce((m, o) => {m[o.id] = o; return m;}, {});
    }
  }

  mapItems(messages) {

    let threads = messages.reduce((m,o) => {
      let threadId = o.root_message_id || o.id;

      if (!o.root_message_id && !m[o.id]) {
        m[o.id] = o;
      }
      else {
        if (!m[o.root_message_id] || m[o.root_message_id].id < o.id) {
          m[o.root_message_id] = o;
        }
      }
      return m;
    }, {});


    let newMessages = messages.map((msg, pos) => {
      let job = this.jobMap[msg.job_id]; // FIXME, if job not here go fetch it

      let rootId = msg.root_message_id || msg.id;

      let tmp = Object.assign({}, msg, {job: job, thread: (threads[rootId].id == msg.id)});
      return tmp;
    });

    this.onItems(newMessages);
  }

  getItems(onLoading) {
    Pyr.getJSON({
      url: MESSAGES_URL,
      context: this,
      loading: onLoading,
    }).done(function(data, textStatus, jaXHR) {
        this.mapItems(data.messages);

    }).fail(function(jaXHR, textStatus, errorThrown) {
      Pyr.ajaxError(jaXHR, textStatus, errorThrown);
    });
  }

  indexSheet() {
    return (
      <IndexSheet 
        {...this.props} 
        items={this.state.items}
        jobMap={this.jobMap}
        selected={this.state.selected}
        onAction={this.onAction}
        onUnaction={this.onUnaction}
        onSelect={this.onSelect}
        onUnselect={this.onUnselect}
        getItems={this.getItems}
      />
    );
  }
  
  actionSheet(action) {
    let sheet = Sheet.sheetComponent(action || "Show");
    let ActionSheet = eval(sheet);

    //alert("actionSheet: " + this.state.selected.id);

    return (
      <ActionSheet 
        {...this.props}
        items={this.state.items}
        jobMap={this.jobMap}
        selected={this.state.selected}
        onAction={this.onAction}
        onUnaction={this.onUnaction}
      />
    );
    
  }
}

function key(item) {
  return "message-" + item.id;
}
MessagesPage.key = key;

export default MessagesPage;
