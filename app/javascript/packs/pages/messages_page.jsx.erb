<% include Rails.application.routes.url_helpers %>
<% include Rails.application.helpers %>

import React, { 
  Component
} from 'react';

import ReactDOM from 'react-dom';

import Pyr from '../pyr/pyr';
const ClassNames = Pyr.ClassNames;

const Grid = Pyr.Grid;

import Page from './page';
import Sheet from './sheet';

const MESSAGES_URL = "/messages";

const icons = ["emilia", "snow", "sophie", "thetick"];

function getIcon(uid) {
  let pos = uid % icons.length;
  return "/assets/images/thrones/" + icons[pos] + ".jpeg";
}

function MID(message) {
  return "message-" + message.id;
}

function THREAD_ID(message) {
  return "thread-item-" + message.id;
}

const Icon = (props) => (
  <div className="flex-column icon justify-content-center align-self-center">
    <div><img src={props.icon}/></div>
    <div className="align-self-center">{props.firstName}</div>
  </div>
);

class ThreadItem extends Sheet.Item {
  renderIcon(message) {
    let icon = getIcon(message.from_user.id);

    return (
      <Icon 
        icon={icon}
        firstName={message.from_user.first_name}
      />
    );
  }

  render() {
    let message = this.props.message;
    let job = this.props.job;

    let mine = message.mine;
    let ownerClass = (mine ? "mine" : "yours");

    let id = THREAD_ID(message);
    let allClass = ClassNames("thread-item", ownerClass);
    if (!message.mine && !message.read_at) {
      allClass.push("unread red");
    }

    let leftIcon = mine ? this.renderIcon(message) : null;
    let rightIcon = mine ? null : this.renderIcon(message);

    let justify = ClassNames("flx-row flx-1");
    if (!mine) {
      justify.push("justify-content-end");
    }

    return (
      <div className={allClass} id={id}>
        <div className={justify.concat("created-at")}>
          <Pyr.MagicDate date={message.created_at} />
        </div>
        <div className={justify}>
          { leftIcon }
          <div className="flx-col justify-content-center">
            <div className={" content flx-0"}>{id}-{message.body}</div>
          </div>
          { rightIcon }
        </div>
      </div>
    );
  }
}

const CandidateHeader = (props) => (
  <div className="message-header" {...Pyr.Util.propsRemove(props, ["job", "message", "isNew"])}>{props.isNew ? "New ": ""}Candidate: <span>{props.job.title}</span></div>
);

const JobQuestionHeader = (props) => (
  <div className="message-header" {...Pyr.Util.propsRemove(props, ["job", "message", "isNew"])}>Q&amp;A: <span>{props.job.title}</span></div>
);

class MessageItem extends Sheet.Item {

  render() {
    let message = this.props.message;
    //console.log(JSON.stringify(message));

    let job = this.props.job;
    let id = MID(message);

    let mine = message.mine;
    let ownerClass = (mine ? "mine" : "yours");

    let allClass = ClassNames("message-item candidate ", ownerClass);

    if (!mine && !message.read_at) {
      allClass.push("unread");
    }

    if (message.is_root) {
      allClass.push("new");
    }

    let Header = message.candidate ? CandidateHeader : JobQuestionHeader

    return (
      <div className={allClass} id={id}>
        <Grid.Column>
          <Grid.Row className="title"> 
            <Grid.Column className="col-9">
              <Header job={job} isNew={message.is_root}/>
            </Grid.Column>
            <Grid.Column className="col-3 created-at text-right">
              <Pyr.MagicDate date={message.created_at} />
            </Grid.Column>
          </Grid.Row>
          <Grid.Row> 
            <Grid.Column className="col-1 avatar">
              {id}:{message.root_message_id}
            </Grid.Column>
            <Grid.Column className="col-11 summary">
              {Pyr.Util.summarize(message.body, 300)}
            </Grid.Column>
          </Grid.Row>
        </Grid.Column>
      </div>
    );
  }
}

class IndexSheet extends Sheet.Index {
  key(a) {
    return MessagesPage.key(a)
  }

  renderItem(message, isSelected) {
    return ( <MessageItem message={message} job={this.props.jobMap[message.job_id]} isSelected={isSelected}/> );
  }

  componentDidMount() {
    if (!this.props.items) {
      this.props.getItems(this.onLoading);
    }
  }

}

class ShowQAHeader extends Component {
  render() {
    let message = this.props.message;

    return (
      <div className="qa-header">
          <div className="align-self-center title">{message.job.title} Questions & Answers</div>
          <div className="from">{message.from_user.first_name} has asked a question about your job posting</div>
          <div className="body">{message.body}</div>
          <div className="align-self-left back"><a href="#" onClick={this.props.onBack}>Back</a></div>
      </div>
    );
  }
}

const ShowMessageHeader = (props) => (
  <div className="message-header">
      <div className="align-self-left back"><a href="#" onClick={props.onBack}>Back</a></div>
      <div className="align-self-center title">{props.title}</div>
  </div>
);

class ShowInner extends Component {
  render() {
    console.log("SHOW INNNER!");
    return (
      <div 
        ref={(node) => this.scrollerOld = (node)}
        id="message-show" 
        className="flx-1 flx-col scroll" 
        onScroll={this.props.onScroll}
      >
        {this.props.children}
      </div>
    );
  }
}

class ShowQA extends Component {
  render() {
    return (
      <div className="sheet flx-col-stretch flx-1">
        <ShowQAHeader 
          message={this.props.message}
          onBack={this.props.onBack}
          title={this.props.title}
        />
        <ShowInner
          onScroll={this.props.onScroll}
        >
          {this.props.children}
        </ShowInner>
      
        <ShowFooter 
          message={this.props.message}
          onSuccess={this.props.onSuccess}
        />
      </div>
    );
  }
}

class ShowThread extends Component {
  render() {
    return (
      <div className="sheet flx-col-stretch flx-1">
        <ShowMessageHeader 
          message={this.props.message}
          onBack={this.props.onBack}
          title={this.props.title}
        />
        <ShowInner
          onScroll={this.props.onScroll}
        >
          {this.props.children}
        </ShowInner>
      
        <ShowFooter 
          message={this.props.message}
          onSuccess={this.props.onSuccess}
        />
      </div>
    );
  }
}

class ShowFooter extends Component {
  componentDidMount() {
  }

  render() {
    return (
      <div className="message-footer z-depth-1">
        <Pyr.Form.Form
          controller="message"
          url={MESSAGES_URL + "/" + this.props.message.id}
          id={"thread-form" + "-" + this.props.message.id}
          onSuccess={this.props.onSuccess}
          ref={(node) => this.form = node}
          reset
        >
          <div className="flx-row">
            <Pyr.Form.Group name="body" className="flx-1">
              <Pyr.Form.TextField 
                placeholder="Reply..."
                ref={(node) => this.textField = node}
                autoFocus
              />
            </Pyr.Form.Group> 
            <Pyr.Form.SubmitButton target={this}>Reply</Pyr.Form.SubmitButton>
          </div>
        </Pyr.Form.Form>
      </div>
    );
  }
}

class ShowSheet extends Sheet.Show {
  getInitState(props) {
    return Object.assign(super.getInitState(props), { thread: null });
  }

  constructor(props) {
    super(props);

    this.onMessageDetails = this.messageDetails.bind(this);
    this.onBack = this.back.bind(this);
    this.onSuccess = this.success.bind(this);
    //this.onScroll = this.scroll.bind(this);
  }

  scroller() {
    let item = $("#message-show")[0];
    console.log("SCROLLER: " + item);
    return item;
    //return this.inner.scroller;
  }

  scroll(e) {
    console.log("******************************");
    console.log("ScrollHeight " + $(this.scroller)[0].scrollHeight);
    console.log("TopScrolled " + $(this.scroller)[0].scrollTop);
    console.log("OffsetScrolled " + $(this.scroller).offset().top);
    console.log("FirstScrolled " + $(this.scroller).children(":first").offset().top);

    console.log("thread-item-17929 " + $("#thread-item-17929").offset().top);
  }

  back(e) {
    if (e) {
      e.preventDefault();
    }

    this.props.onSetUnaction();
  }

  threadExtra(thread) {
    let all = [];
    let userId = this.context.user.id;

    thread.map((item, pos) => {
      item.is_root = !item.root_message_id;
      item.mine = (item.from_user.id == userId);
      item.read_at = new Date(); // got it so pretend it's been read, server is updating
    });

    return thread;
  }

  setThread(thread) {
    this.setState({
      thread: this.threadExtra(thread)
    });

  }

  success(data, textStatus, jqXHR) {
    let thread = this.state.thread || [];
    thread = thread.concat(data.message);

    this.setThread(thread);

    let itemDict = this.props.items.reduce((results, item) => {
      results[item.id] = item;
      return results;
    }, {} );

    for(let item of thread) {
      if (itemDict[item.id]) {
        console.log("Replacing: " + item.id);
      }
      itemDict[item.id] = item;
    }

    this.props.onSetItems(Object.values(itemDict));
  }

  render() {
    if (this.state.isLoading || !this.props.selected) {
      return (<Pyr.Loading />);
    }

    let title = this.props.selected.job.title; // FIXME

    if (!this.props.selected.candidate) {
      return (
        <ShowQA
          ref={(node) => this.inner = node}
          title={title}
          message={this.props.selected}
          onBack={this.onBack}
          onScroll={this.props.onScroll}
          onSuccess={this.onSuccess}
        >
          {this.renderInner()}
        </ShowQA>
      );
    }

    return(
      <ShowThread
        ref={(node) => this.inner = node}
        title={title}
        message={this.props.selected}
        onBack={this.onBack}
        onScroll={this.props.onScroll}
        onSuccess={this.onSuccess}
      >
        {this.renderInner()}
      </ShowThread>
    );
  }


  key(a) {
    return MessagesPage.key(a)
  }

  messageDetails(message, thread) {
    //alert(JSON.stringify(thread));
    // FIXME ignore message, we already have it in props.selected - FOR NOW ;)
    this.setThread(thread);
  }

  getMessage(mid) {
    let url =  MESSAGES_URL + "/" + mid;
    //alert(url);
    Pyr.getJSON({
      url: url,
      context: this,
      loading: this.onLoading
    }).done(function(data, textStatus, jaXHR) {
     this.onMessageDetails(data.message, data.thread);
   
    }).fail(function(jaXHR, textStatus, errorThrown) {
      Pyr.ajaxError(jaXHR, textStatus, errorThrown);
    });
  }

  componentDidMount() {
    if (this.props.selected) {
      this.getMessage(this.props.selected.id);
    }
  }

  topPos(item) {
    let $parent = $(item).parent();
    let $scroll = $(this.scroller());

    let top = $(item).offset().top;

    console.log("TOP: " + $(item).attr("id") + " => " + top);
    //while($parent.attr("id") != "message-show") {
    while($parent.attr("id") != $scroll.attr("id")) {
      console.log("TOP: " + $parent.attr("id") + " => " + top);
      top = top - $parent.offset().top;

      $parent = $parent.parent();
      console.log("PARENT IS NOW: " + $parent.attr("id"));
    }

    return top;
  }

  firstUnread() {
    let messages = this.state.thread;

    let pos = messages.reduce((result, m, index) => {
      if (m.mine || m.read_at) {
        return index;
      }
      return result;
    }, 0);
    //console.log("READ POS: " + pos);
    return messages[pos];
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.props.selected && (this.props.selected.id != prevProps.selected.id)) {
      this.getMessage(this.props.selected.id);
    }
    let oldLength = prevState.thread ? prevState.thread.length : 0;
    let newLength = this.state.thread ? this.state.thread.length : 0;

    console.log("UPDATE: " + oldLength + " => " + newLength);

    if (oldLength != newLength) {
      this.scrollToLastRead(oldLength == 0);
    }
  }

  scrollToLastRead(firstUnread=false) {
    console.log("SCROLL TO LAST");

    if (!firstUnread) {
      console.log("Scroll To Bottom");
      console.log("Scroll Height: " + this.scroller().scrollHeight);
      $(this.scroller()).stop().animate({
        scrollTop: this.scroller().scrollHeight
      }, 800);
      return;
    }

    let topMessage = this.firstUnread();
    let mid = THREAD_ID(topMessage);

    let $item = $("#" + mid);
    let $scroll = $(this.scroller());

    let showTop = this.scroller().scrollHeight;
    let top = this.topPos($item) + $scroll.offset().top + $item.height();

    $scroll.stop().scrollTop(top);
  }


  renderItem(message, isSelected) {
    if (!this.state.thread || this.state.thread.length < 1) {
      return (<Pyr.Loading />);
    }

    let thid = "thread-" + this.props.selected.root_message_id;

    return (
      <div id={thid} className="message-thread flx-1">
        { 
          this.state.thread.map((msg, pos) => {
            //console.log(msg.job_id + " => " + JSON.stringify(this.props.jobMap[message.job_id]));
            return ( <ThreadItem message={msg} 
                      job={this.props.jobMap[message.job_id]} 
                      isSelected={msg.id == this.props.selected.id} 
                      key={thid+"-"+msg.id}/> 
            );
          })
        }
      </div>
    );
  }
}

class MessagesPage extends Page {
  getInitState(props) {
    return Object.assign(super.getInitState(props), { 
      fullDetail: true,
    });
  }

  constructor(props) {
    super(props);

    let jobs = this.props.jobs || [];
    this.jobMap = jobs.reduce((m, o) => {m[o.id] = o; return m;}, {});
    this.onSetItems = this.setItems.bind(this);
  }

  key(a) {
    return "message" + "-" + a.id;
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.props.jobs != prevProps.jobs) {
      let jobs = this.props.jobs || [];
      this.jobMap = jobs.reduce((m, o) => {m[o.id] = o; return m;}, {});
    }
  }

  reduceItems(messages) { // throw out all but the last from the thread

    let threads = messages.reduce((mmap, msg) => {
      let threadId = msg.root_message_id || msg.id;

      if (!mmap[threadId] || mmap[threadId].id < msg.id) {

        let job = this.jobMap[msg.job_id]; // FIXME, if job not here go fetch it
        let mine = (msg.from_user.id == this.context.user.id);
        let is_root = !msg.root_message_id;

        mmap[threadId] = Object.assign({}, msg, { job, mine, is_root});
      }
      return mmap;
    }, {});

    return Object.values(threads);

  }

  setItems(items) {
    items = this.reduceItems(items);
    super.setItems(items);
  }

  getItems(onLoading) {
    Pyr.getJSON({
      url: MESSAGES_URL,
      context: this,
      loading: onLoading,
    }).done(function(data, textStatus, jaXHR) {
        this.onSetItems(data.messages);

    }).fail(function(jaXHR, textStatus, errorThrown) {
      Pyr.ajaxError(jaXHR, textStatus, errorThrown);
    });
  }

  setSelected(selected) {
    selected.read_at = new Date();
    super.setSelected(selected);
  }

  indexSheet() {
    return (
      <IndexSheet 
        {...this.props} 
        items={this.state.items}
        jobMap={this.jobMap}
        selected={this.state.selected}
        onSetAction={this.props.onSetAction}
        onSetUnaction={this.props.onSetUnaction}
        onSelect={this.onSelect}
        onUnselect={this.onUnselect}
        getItems={this.getItems}
      />
    );
  }
  
  actionSheet(action) {
    let sheet = Sheet.sheetComponent(action || "Show");
    let ActionSheet = eval(sheet);

    //alert("actionSheet: " + this.state.selected.id);

    return (
      <ActionSheet 
        {...this.props}
        items={this.state.items}
        jobMap={this.jobMap}
        selected={this.state.selected}
        onSetItems={this.onSetItems}
        onSetAction={this.props.onSetAction}
        onSetUnaction={this.props.onSetUnaction}
      />
    );
    
  }
}

function key(item) {
  return "message-" + item.id;
}
MessagesPage.key = key;

export default MessagesPage;
