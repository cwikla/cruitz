<% include Rails.application.routes.url_helpers %>
<% include Rails.application.helpers %>

import React, { 
  Component
} from 'react';

import ReactDOM from 'react-dom';

import Pyr from '../../pyr/pyr';
const ClassNames = Pyr.ClassNames;
const Grid = Pyr.Grid;
import Page from '../page';
import Sheet from '../sheet';
import ThreadItem, { THREAD_ID } from './thread_item';

import MessageThread, { 
  MessageThreadHeader,
  MessageThreadIndexHeader
} from './message_thread';
import MessageQA, { MessageQAHeader } from './message_qa';

const MESSAGES_URL = "/messages";


function MID(message) {
  return "message-" + message.id;
}

class MessageItem extends Sheet.Item {

  render() {
    let message = this.props.message;
    //console.log(JSON.stringify(message));

    let job = this.props.job;
    let id = MID(message);

    let mine = message.mine;
    let ownerClass = (mine ? "mine" : "yours");

    let allClass = ClassNames("message-item", ownerClass);

    if (!mine && !message.read_at) {
      allClass.push("unread");
    }

    if (message.is_root) {
      allClass.push("new");
    }

    let Header = message.candidate ? MessageThreadIndexHeader : MessageQAHeader;

    return (
      <div className={allClass} id={id}>
        <Grid.Column>
          <Grid.Row className="title"> 
            <Grid.Column className="col-9">
              <Header job={job} isNew={message.is_root}/>
            </Grid.Column>
            <Grid.Column className="col-3 created-at text-right">
              <Pyr.MagicDate date={message.created_at} />
            </Grid.Column>
          </Grid.Row>
          <Grid.Row> 
            <Grid.Column className="summary">
              {Pyr.Util.summarize(message.body, 300)}
            </Grid.Column>
          </Grid.Row>
        </Grid.Column>
      </div>
    );
  }
}

class IndexSheet extends Sheet.Index {
  key(a) {
    return MessagesPage.key(a)
  }

  renderItem(message, isSelected) {
    return ( <MessageItem message={message} job={this.props.jobMap[message.job_id]} isSelected={isSelected}/> );
  }

}


class ShowSheet extends Sheet.Show {
  constructor(props) {
    super(props);

    this.onBack = this.back.bind(this);
  }

  back(e) {
    if (e) {
      e.preventDefault();
    }

    this.props.onSetUnaction();
  }

  render() {
    if (this.state.isLoading || !this.props.selected) {
      return (<Pyr.Loading />);
    }

    let message = this.props.selected;
    let MessageRender = this.props.selected.candidate ? MessageThread : MessageQA;

    return (
      <div className="d-flex flx-1 flx-col">
        <MessageThreadHeader
          message={message}
          job={this.props.jobMap[message.job_id]}
          onBack={this.onBack}
          url={Pyr.URL(MESSAGES_URL)}
        />
        <MessageRender
          message={message}
          job={this.props.jobMap[message.job_id]}
          onBack={this.onBack}
          url={Pyr.URL(MESSAGES_URL)}
        />
      </div>
    );
  }


  key(a) {
    return MessagesPage.key(a)
  }

  renderItem(message, isSelected) {
    if (!this.state.thread || this.state.thread.length < 1) {
      return (<Pyr.Loading />);
    }

    let thid = "thread-" + this.props.selected.root_message_id;

    return (
      <div id={thid} className="message-thread flx-1">
        { 
          this.state.thread.map((msg, pos) => {
            //console.log(msg.job_id + " => " + JSON.stringify(this.props.jobMap[message.job_id]));
            return ( <ThreadItem message={msg} 
                      job={this.props.jobMap[message.job_id]} 
                      isSelected={msg.id == this.props.selected.id} 
                      key={thid+"-"+msg.id}/> 
            );
          })
        }
      </div>
    );
  }
}

///////////////

class MessagesPage extends Page {
  getInitState(props) {
    return Object.assign(super.getInitState(props), { 
      fullDetail: true,
    });
  }

  constructor(props) {
    super(props);

    let jobs = this.props.jobs || [];
    this.jobMap = jobs.reduce((m, o) => {m[o.id] = o; return m;}, {});
    this.onSetItems = this.setItems.bind(this);
  }

  key(a) {
    return "message" + "-" + a.id;
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.props.jobs != prevProps.jobs) {
      let jobs = this.props.jobs || [];
      this.jobMap = jobs.reduce((m, o) => {m[o.id] = o; return m;}, {});
    }
  }

  reduceItems(messages) { // throw out all but the last from the thread

    let threads = messages.reduce((mmap, msg) => {
      let threadId = msg.root_message_id || msg.id;

      if (!mmap[threadId] || mmap[threadId].id < msg.id) {

        let job = this.jobMap[msg.job_id]; // FIXME, if job not here go fetch it
        let mine = (msg.from_user.id == this.context.user.id);
        let is_root = !msg.root_message_id;

        mmap[threadId] = Object.assign({}, msg, { job, mine, is_root});
      }
      return mmap;
    }, {});

    return Object.values(threads);

  }

  setItems(items) {
    items = this.reduceItems(items);
    let count = items.reduce((sum, msg) => {
      sum = sum + ((msg.mine || msg.read_at) ? 0 :1);
      return sum;
    }, 0);
    this.props.onSetButtonCount("Messages", count);
    super.setItems(items);
  }

  getItems(onLoading) {
    Pyr.getJSON({
      url: Pyr.URL(MESSAGES_URL),
      context: this,
      loading: onLoading,
    }).done(function(data, textStatus, jaXHR) {
        this.onSetItems(data.messages);

    }).fail(function(jaXHR, textStatus, errorThrown) {
      Pyr.ajaxError(jaXHR, textStatus, errorThrown);
    });
  }

  setSelected(selected) {
    selected.read_at = new Date();
    super.setSelected(selected);
  }

  indexSheet() {
    return (
      <IndexSheet 
        {...this.props} 
        items={this.state.items}
        jobMap={this.jobMap}
        selected={this.state.selected}
        onSetAction={this.props.onSetAction}
        onSetUnaction={this.props.onSetUnaction}
        onSelect={this.onSelect}
        onUnselect={this.onUnselect}
        getItems={this.getItems}
      />
    );
  }
  
  actionSheet(action) {
    let sheet = Sheet.sheetComponent(action || "Show");
    let ActionSheet = eval(sheet);

    //alert("actionSheet: " + this.state.selected.id);

    return (
      <ActionSheet 
        {...this.props}
        items={this.state.items}
        jobMap={this.jobMap}
        selected={this.state.selected}
        onSetItems={this.onSetItems}
        onSetAction={this.props.onSetAction}
        onSetUnaction={this.props.onSetUnaction}
      />
    );
    
  }
}

function key(item) {
  return "message-" + item.id;
}
MessagesPage.key = key;

export default MessagesPage;
